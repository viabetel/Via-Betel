generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Lead do aluno solicitando orçamento (sem contato direto com instrutor)
model Lead {
  id               String           @id @default(cuid())
  city             String
  neighborhood     String?
  category         String          // CNH desejada
  availability1    String          // opção 1
  availability2    String?         // opção 2
  availability3    String?         // opção 3
  objective        String?         // baliza, medo, prova, etc
  notes            String?
  studentName      String?         // opcional
  studentWhatsApp  String?         // opcional (nunca exposto ao instrutor)
  status           LeadStatus      @default(PENDING)
  createdAt        DateTime        @default(now())
  
  proposals        LeadProposal[]
  
  @@map("leads")
}

// Proposta do instrutor para um lead
model LeadProposal {
  id              String   @id @default(cuid())
  leadId          String
  lead            Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  instructorId    String
  instructor      Instructor @relation(fields: [instructorId], references: [id], onDelete: Cascade)
  message         String
  suggestedPrice  Int      // em centavos
  availability    String   // ex: "Segunda 08:00-12:00"
  createdAt       DateTime @default(now())
  
  @@map("lead_proposals")
}

// Instrutor (paga assinatura para aparecer no catálogo)
model Instructor {
  id               String          @id @default(cuid())
  slug             String          @unique
  name             String
  email            String          @unique
  city             String
  state            String
  categories       String          // "A,B,C"
  rating           Float           @default(4.5)
  price            Int             // em centavos
  specialties      String          // JSON array
  status           InstructorStatus @default(PENDING)
  createdAt        DateTime        @default(now())
  
  subscription     Subscription?
  boosts           Boost[]
  proposals        LeadProposal[]
  
  @@map("instructors")
}

// Assinatura do instrutor (Stripe Subscription)
model Subscription {
  id                      String              @id @default(cuid())
  instructorId            String              @unique
  instructor              Instructor          @relation(fields: [instructorId], references: [id], onDelete: Cascade)
  planId                  String
  plan                    Plan                @relation(fields: [planId], references: [id])
  status                  SubscriptionStatus  @default(ACTIVE)
  startedAt               DateTime            @default(now())
  expiresAt               DateTime?
  canceledAt              DateTime?
  stripeCustomerId        String?             // opcional para futuro
  stripeSubscriptionId    String?             // opcional para futuro
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt

  @@index([planId])
  @@map("subscriptions")
}

// Impulsionamento/Anúncios (add-on pago)
model Boost {
  id                String   @id @default(cuid())
  instructorId      String
  instructor        Instructor @relation(fields: [instructorId], references: [id], onDelete: Cascade)
  type              BoostType
  city              String
  startsAt          DateTime
  endsAt            DateTime
  stripePaymentId   String?
  createdAt         DateTime @default(now())
  
  @@map("boosts")
}

// Plano do instrutor
model Plan {
  id          String        @id @default(cuid())
  slug        String        @unique
  name        String
  description String
  priceCents  Int
  interval    PlanInterval
  features    Json
  maxListings Int           @default(1)
  highlight   Boolean       @default(false)
  badge       String?       // badge visual no marketplace
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  subscriptions Subscription[]

  @@map("plans")
}

// Regras:
// - Instrutores sem plano ativo podem responder até 7 alunos diferentes por mês
// - O contador reseta no início de cada mês (baseado em year + month)
// - Conversas já iniciadas no mês atual não contam novamente
model MonthlyChatUsage {
  id                String   @id @default(cuid())
  
  // Instrutor que está usando
  userId            String
  
  // Período: ano e mês para reset automático
  year              Int
  month             Int
  
  // Quantas conversas distintas o instrutor respondeu neste mês
  usedConversations Int      @default(0)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, year, month])
  @@index([userId])
  @@map("monthly_chat_usage")
}

// Evita contar a mesma conversa múltiplas vezes no mesmo mês
model ConversationUsageLog {
  id              String   @id @default(cuid())
  
  userId          String      // instrutor
  conversationId  String      // ID da conversa
  year            Int
  month           Int
  
  // Quando o instrutor respondeu pela primeira vez nesta conversa neste mês
  firstReplyAt    DateTime @default(now())
  
  @@unique([userId, conversationId, year, month])
  @@index([userId, year, month])
  @@map("conversation_usage_logs")
}

enum LeadStatus {
  PENDING
  CONTACTED
  CLOSED
}

enum InstructorStatus {
  PENDING
  ACTIVE
  INACTIVE
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  EXPIRED
}

enum PlanInterval {
  MONTHLY
  YEARLY
}

enum BoostType {
  IMPULSIONAR_7_DIAS
  VITRINE_30_DIAS
}
