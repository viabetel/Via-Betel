generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Lead do aluno solicitando orçamento (sem contato direto com instrutor)
model Lead {
  id               String           @id @default(cuid())
  city             String
  neighborhood     String?
  category         String          // CNH desejada
  availability1    String          // opção 1
  availability2    String?         // opção 2
  availability3    String?         // opção 3
  objective        String?         // baliza, medo, prova, etc
  notes            String?
  studentName      String?         // opcional
  studentWhatsApp  String?         // opcional (nunca exposto ao instrutor)
  status           LeadStatus      @default(PENDING)
  createdAt        DateTime        @default(now())
  
  proposals        LeadProposal[]
  
  @@map("leads")
}

// Proposta do instrutor para um lead
model LeadProposal {
  id              String   @id @default(cuid())
  leadId          String
  lead            Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  instructorId    String
  instructor      Instructor @relation(fields: [instructorId], references: [id], onDelete: Cascade)
  message         String
  suggestedPrice  Int      // em centavos
  availability    String   // ex: "Segunda 08:00-12:00"
  createdAt       DateTime @default(now())
  
  @@map("lead_proposals")
}

// Instrutor (paga assinatura para aparecer no catálogo)
model Instructor {
  id               String          @id @default(cuid())
  slug             String          @unique
  name             String
  email            String          @unique
  city             String
  state            String
  categories       String          // "A,B,C"
  rating           Float           @default(4.5)
  price            Int             // em centavos
  specialties      String          // JSON array
  status           InstructorStatus @default(PENDING)
  createdAt        DateTime        @default(now())
  
  subscription     Subscription?
  boosts           Boost[]
  proposals        LeadProposal[]
  
  @@map("instructors")
}

// Assinatura do instrutor (Stripe Subscription)
model Subscription {
  id                      String              @id @default(cuid())
  instructorId            String              @unique
  instructor              Instructor          @relation(fields: [instructorId], references: [id], onDelete: Cascade)
  planId                  String
  plan                    Plan                @relation(fields: [planId], references: [id])
  status                  SubscriptionStatus  @default(ACTIVE)
  startedAt               DateTime            @default(now())
  expiresAt               DateTime?
  canceledAt              DateTime?
  stripeCustomerId        String?             // opcional para futuro
  stripeSubscriptionId    String?             // opcional para futuro
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt

  @@index([planId])
  @@map("subscriptions")
}

// Impulsionamento/Anúncios (add-on pago)
model Boost {
  id                String   @id @default(cuid())
  instructorId      String
  instructor        Instructor @relation(fields: [instructorId], references: [id], onDelete: Cascade)
  type              BoostType
  city              String
  startsAt          DateTime
  endsAt            DateTime
  stripePaymentId   String?
  createdAt         DateTime @default(now())
  
  @@map("boosts")
}

// Plano do instrutor
model Plan {
  id          String        @id @default(cuid())
  slug        String        @unique
  name        String
  description String
  priceCents  Int
  interval    PlanInterval
  features    Json
  maxListings Int           @default(1)
  highlight   Boolean       @default(false)
  badge       String?       // badge visual no marketplace
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  subscriptions Subscription[]

  @@map("plans")
}

// Regras:
// - Instrutores sem plano ativo podem responder até 7 alunos diferentes por mês
// - O contador reseta no início de cada mês (baseado em year + month)
// - Conversas já iniciadas no mês atual não contam novamente
model MonthlyChatUsage {
  id                String   @id @default(cuid())
  
  // Instrutor que está usando
  userId            String
  
  // Período: ano e mês para reset automático
  year              Int
  month             Int
  
  // Quantas conversas distintas o instrutor respondeu neste mês
  usedConversations Int      @default(0)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, year, month])
  @@index([userId])
  @@map("monthly_chat_usage")
}

// Evita contar a mesma conversa múltiplas vezes no mesmo mês
model ConversationUsageLog {
  id              String   @id @default(cuid())
  
  userId          String      // instrutor
  conversationId  String      // ID da conversa
  year            Int
  month           Int
  
  // Quando o instrutor respondeu pela primeira vez nesta conversa neste mês
  firstReplyAt    DateTime @default(now())
  
  @@unique([userId, conversationId, year, month])
  @@index([userId, year, month])
  @@map("conversation_usage_logs")
}

// Solicitação do aluno para instrutor
model Request {
  id              String          @id @default(cuid())
  studentId       String
  instructorId    String?         // null = pedido aberto
  title           String
  description     String
  category        String
  city            String
  preferredDates  String?         // JSON array
  budget          Int?            // em centavos
  status          RequestStatus   @default(NEW)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  events          RequestEvent[]
  conversation    Conversation?

  @@index([studentId])
  @@index([instructorId])
  @@index([status])
  @@map("requests")
}

enum RequestStatus {
  NEW
  VIEWED
  RESPONDED
  AGREED
  COMPLETED
  CANCELED
  EXPIRED
}

// Eventos da solicitação (timeline)
model RequestEvent {
  id          String    @id @default(cuid())
  requestId   String
  request     Request   @relation(fields: [requestId], references: [id], onDelete: Cascade)
  type        String    // ex: "created", "viewed", "responded", "agreed", "completed"
  description String?
  createdAt   DateTime  @default(now())

  @@index([requestId])
  @@map("request_events")
}

// Conversa entre aluno e instrutor
model Conversation {
  id          String      @id @default(cuid())
  requestId   String      @unique
  request     Request     @relation(fields: [requestId], references: [id], onDelete: Cascade)
  studentId   String
  instructorId String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  messages    Message[]

  @@index([requestId])
  @@index([studentId])
  @@index([instructorId])
  @@map("conversations")
}

// Mensagem no chat
model Message {
  id              String      @id @default(cuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId        String
  content         String?     // null se for arquivo
  fileUrl         String?     // URL do arquivo em storage
  fileType        String?     // "file" ou "image"
  fileName        String?
  createdAt       DateTime    @default(now())

  reads           MessageRead[]

  @@index([conversationId])
  @@index([createdAt])
  @@map("messages")
}

// Marcação de lido
model MessageRead {
  id          String    @id @default(cuid())
  messageId   String
  message     Message   @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId      String
  readAt      DateTime  @default(now())

  @@unique([messageId, userId])
  @@map("message_reads")
}

// Documento de verificação do instrutor
model Document {
  id          String                @id @default(cuid())
  ownerId     String
  type        String                // "cnh", "certificate", "license"
  fileUrl     String
  status      VerificationStatus    @default(PENDING_DOCS)
  rejectReason String?
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt

  @@index([ownerId])
  @@index([status])
  @@map("documents")
}

enum VerificationStatus {
  PENDING_DOCS
  UNDER_REVIEW
  VERIFIED
  REJECTED
}

// Log de auditoria
model AuditLog {
  id          String    @id @default(cuid())
  action      String    // ex: "request_created", "message_sent"
  userId      String
  entityType  String    // ex: "Request", "Message"
  entityId    String
  details     Json?     // detalhes da ação
  createdAt   DateTime  @default(now())

  @@index([userId])
  @@index([entityType])
  @@map("audit_logs")
}

// Instrutor Profile
model InstructorProfile {
  id                   String                     @id @default(cuid())
  userId               String                     @unique
  fullName             String
  phone                String?
  city                 String?
  state                String?
  categories           String?                    // ex: "A,B,C"
  yearsExp             Int?

  // Vínculo profissional
  isLinkedToAutoescola Boolean                    @default(false)
  autoescolaName       String?
  autoescolaCnpj       String?

  // Documentos (URLs)
  cnhUrl               String?
  certificadoUrl       String?
  vinculoUrl           String?

  status               InstructorVerificationStatus @default(INCOMPLETO)
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt

  user                 User                       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("instructor_profiles")
}

model User {
  id                   String                     @id @default(cuid())
  email                String                     @unique
  created_at           DateTime                   @default(now())

  instructorProfile    InstructorProfile?

  @@map("users")
}

enum LeadStatus {
  PENDING
  CONTACTED
  CLOSED
}

enum InstructorStatus {
  PENDING
  ACTIVE
  INACTIVE
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  EXPIRED
}

enum PlanInterval {
  MONTHLY
  YEARLY
}

enum BoostType {
  IMPULSIONAR_7_DIAS
  VITRINE_30_DIAS
}

enum InstructorVerificationStatus {
  INCOMPLETO
  EM_ANALISE
  APROVADO
  REPROVADO
}
